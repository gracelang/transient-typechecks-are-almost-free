%!TEX root = ../latex/paper.tex

\sm{this is a deep dive.
Do we already have the context established here?
perhaps. but even if, the reader needs guidance about what this section is about}
We implement Grace's gradual-structural type system as an extension to the core of Moth.
\sm{can we just simply say that these things are going to be explained?
With less words, and giving more guidance to the reader?}
The extension involves a mechanism to extract structural types declared in the program, a mechanism to extract structural types from both primitives and objects defined in the program, and a mechanism to efficiently manage the types and the knowledge of which types subtype other types. \del{We describe each of these three components in this section (the implementation of the checking algorithm is described in \cref{ssec:managing-types}). Decisions made for optimization are presented last in Subsection \ref{ssec:optimization-details}).} 

\subsection{Extracting Structure}
\label{ssec:optimization-details}
\sm{I don't like the title, it is implying some process.
Why does it need to be a process?
Also, you don't describe a process.
You only describe what constitutes the structure, IMHO, sufficient, and possibly better}

All values in Grace, even \ugh{primitives}\sm{what are primitives? example?}, are \del{expressed as }objects.
Each object has an \ugh{inherit}\sm{what?} structure:
the structure of an object is defined by the names of its methods and the typing information attached to a methods parameters \ugh{are}\sm{and?} return value.\sm{we don't use this for defining types, we only use this for checking, no? we need to make this distinction very clear.
Those are two different aspects that do not seem to be explained}

Where the typing information is omitted,
we associate a special ``Unknown'' type that passes any type check.

Our implementation uses the notion of \emph{fragments}. A fragment is a piece of a structural type. A fragment encapsulates an ordered set of symbols and an ordered set of types.\sm{the second part seems wrong. we only do symbols, no?}

\begin{equation}
f = \{   \{ s_1, s_2, \cdots, s_n \}   \{ t_1, t_2, \cdots, t_n \}  \}
\end{equation}

The symbols together correspond to a method name (Grace's methods feature multiple parts) and the types correspond to the arguments of the method along with its return type. The list of symbols is always known statically; however, the list of types may be incomplete (when annotations for the types are omitted).

\subsection{Subtyping Relationships}
\label{ssec:subtyping-relationships}

For a type $a$ to be a subtype of $b$, each fragment in $b$ must be successfully matched by a fragment in $a$. Finally, for one fragment to match another, (1) each symbol in the fragment must be equal to the corresponding symbol from the other fragment corresponding and (2) each type in the fragment must be a subtype of the corresponding type from the other fragment. 

To avoid the potential for the matching system to repeat recursively, we introduce a table\sm{perhaps better matrix?} that caches the sub-typing relations. Both the rows and columns of the table correspond to types. Each cell contains one of three possible values: false, true, or unknown. 

Whenever we encounter an unknown relations, we immediately evaluate the sub-typing as described above and update the corresponding cell in the table.

\subsection{Optimization Details}
\label{ssec:optimization-details}

