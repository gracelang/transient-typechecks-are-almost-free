%!TEX root = ../latex/paper.tex

\section{Related Work}

\paragraph{VM already knew that}

\begin{cnote}
- based on Higgs JavaScript VM
- SafeTypeScript
  - system of object contracts
  - checked lazily where possible
    i.e., when accessing an object (reading, writing fields, method invocations are preceded by field read)
    for a function object, which may have contracts, before it is invoked
  - as described in sec. XX, we only check the availability of methods/fields
    in a type
    - this has also consequences on checking higher-order functions
      - we only check whether they take the expected number of arguments,
        which is part of their type, but don't check types of their arguments
        (same for normal methods)
  - optimized by recording the object contracts as part of the shape
  - this technique is essentially identical to ours
    - our type information is encoded in the shape, too
    - however, we check conformance eagerly
      - this is as part of having semantics for Grace that provide immediate
        feedback on correctness
    - from a performance perspective, their approach could have an even higher
      cost: increased degree of polymorphism (ours is not increased,
      because we do not use shape trees.
      each class has a single shape, shared by all instances
      the type is based on the specified members, which are statically known)

- Higgs
  - no inlining, escape analysis, tuned GC, etc.
  - any optimizations across basic blocks (beside type propagation)

\end{cnote}


\paragraph{On the Cost of Type-Tag Soundness}
\begin{cnote}
- based on Reticulated Python
  - Python 3-based implementation (interpretation, no compilation)
- soundness notion and supported semantics very similar to ours
- evaluate the performance in detail
 - generate different variants to see how the number of type checks correlate
   with performance
 - we could possibly do the same, but expect similar results and instead
   focused on identifying more precisely which types of type annotations
   might relate to performance issues
   - thus, we only tested N configurations per benchmark\sm{N should be a macro}
\end{cnote}

\paragraph{Pycket}
\begin{cnote}
- argument about acceptable performance made indirectly
  using the "CDF-based slowdown plots"
  - allows choice of arbitrary threshold of what is acceptable overhead
    - Pycket always better than Racket
    - not as applicable in our case, because we don't do module-based typing
  - use Typed Racket's approach to gradual type checking
  - optimize it by using object shapes, as we do
    however, because of their more sophisticated semantics,
    the optimization does only remove part of the overhead
    specifically, they optimize the number of objects that need to be traversed
    to perform checks based on their contracts
    however, they can not reduce it to a simple pointer comparison as in our
    case, though they get the benefit of more precise checks
\end{cnote}
