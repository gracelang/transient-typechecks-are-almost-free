%!TEX root = ../latex/paper.tex

\section{Discussion}
\label{sec:discussion}

\paragraph{The VM Could Not Already Know That.}
\label{sec:disc-pathological-case}

% - pathological case
%   in this case, we introduce a new type check that does not coincide with any
%   existing checks (shape check on method dispatch, etc)
%   consequently, we see overhead that can be up to XX\% (cf. sec. XX).


One of the key optimizations for our
and the work of others\citep{Richards2017,Bauman2017}
is the use of object shapes
to encode information about types as in our case,
or type casts and type assumptions in the case of gradual type systems.

The general idea is that a VM will already use object shapes
for method dispatches, field accesses, and other operations on objects.
Thus, any further use, for instance to also imply type information could simply
be optimized away by a compiler since it sees that the same checks are
done and can be combined similar to 
other side-effect-free common subexpressions.

However, this assumption breaks when dynamic type checking
introduces checks that do not correspond to already existing checks.
As described in \cref{sec:method},
our approach introduces checks for reading and writing to variables.
\Cref{ex:pathological-case} gives an example of a pathological case.
It is a loop traversing a linked list.
For our type checking,
it introduces checks on assigning to \code{elem}, on reading from \code{elem},
and when activating the \code{next} method.
The checks for reading from \code{elem} and activating the method can be
combined with the already done check of the object shape when doing the
dispatch to \code{next}.
%
Unfortunately, the compiler can not remove the check
when writing to \code{elem}, because it has no information about
what \code{next} is going to read and it needs to be able to trigger an error
on the assignment.
For our List benchmark, this check induces an overhead of \OverheadListP.
\sm{I am not sure why this does not fold with the .next check.
I am sure that it couldn't when we were at the whiteboad,
but I don't see it any more}

\begin{lstlisting}[caption={Example for dynamic type checks not corresponding to existing checks.},escapechar=|,label={ex:pathological-case},float,floatplacement=htb]
var elem: ListElement = headOfList
while (...) {
  elem = elem.next
}
\end{lstlisting}


\begin{cnote}



- possible optimization for reads
  - we can use truffle's approach to specializing ASTs to propagate
    type constraints into the code we are using, which means,
    all type checks can be omitted for code that promises to obey
    type constraints.
    Idea: pass expected return type down, don't check it when getting
     the return value. instead, us truffle approach of reverting optimizations
     by indicating violations with an exception.
 \sm{do we say very precisely what is done in the implementation section?}
 
 
 \sm{the set of changes necessary for the support.
 how much did we need to change to make it work?
 }
 - discuss what the effect of dropping checks on reads would be
   -> need to change more of the primitives
   -> don't do this a the moment
   -> could give performance benefits (experiment?)
   -> but would either delay errors (more imprecision)
      or require all assignments, also from primitives to be checked
\end{cnote}

