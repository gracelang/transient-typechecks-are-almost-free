%!TEX root = ../latex/paper.tex

\section{A Dynamic Type-Checking System}
\label{sec:method}

% \1 motivation
%     \2 has to be fast
%     \2 has to be simple to implement
% \1 high performance implementation
% \1 AST based

Our motivation, as outlined in \cref{sec:introduction}, is to provide developers with
a type system that verifies a program's execution \ugh{conforms to its documentation}.\sm{don't think we can phrase it like this. Also, James teaching argument is also good. might want to revisit this once motivation has stabilized}

Our type system should also be light-weight; 
adding marginal overhead in terms of execution time and
involve little work to implement.

Here we describe how we have added support for our type system to Moth,
an AST-interpreter for the Grace programming language offering fast peak performance,\sm{might want to make this more concrete}
described further in \cref{sec:background}. 




% \1 types defined as list of members
%     \2 example of what that means
% \1 annotations attached to methods (args and return), fields, and variable declarations
% \1 we consider object is type when obj can has each member collected by type
%     \2 examples of what's supported


\subsection{Design}

\sm{why is this another file???}
\sm{can this be a single listing and then you just reference lines? you can label lines in lstlisting for use with cref}
\input{../content/example-annotations}

Since Grace is \ugh{structurally typed}\sm{background doesn't talk about this, perhaps we need to avoid it}, 
the relationship between a value and a type is evaluated in terms of structure rather than nomination.
\rrtodo{the next sentence needs improvement}.
Furthermore Grace is a \ugh{message-based language}\sm{didn't talk about this either},
meaning that the set of messages an object can respond to defines its structure.
The programmer can first attach names to types using an interface syntax as illustrated by \cref{code:type-literal}
and then attached annotate variable (\cref{code:type-annotation-variable})
and method declarations (\cref{code:type-annotation-method})
with those types. 
The interface syntax can also be used directly as an annotation (\ref{code:type-annotation-literal}).

To favor simplicity,
we design our system to treat types as no more than the list of methods that an object should respond to.
Consequently, our design consider an object to 
conform to a type when it can respond to each of that types members and
also considers one type a subtype of another 
when its set of members form a subset of the other's members.

\rephrase{Our system supports type checking whenever an argument can be placed in Grace}:\sm{this sounds strange} 
on arguments, values returned from methods, and on variables.
Arguments are checked before the body of a method is executed,
return values after the execution of a method, and
variables constitute a check whenever they are read from or assigned to.

As a first example, 
consider the declaration of the \textsc{Timer}\sm{why is this sc and not \textbackslash{}code?} type declared in \cref{code:stopwatch}. 
By specifying that the ``stopwatch'' method should return a ``Timer'', 
the programmer can be sure that, void of any type errors during execution,
that the resulting object will respond to the ``elapsed'' message.

\sm{what is the benefit of putting things in separate files?
this just seems to make my life harder.
I might have understood if you'd have used lstinputlistings,
but this way, there doesn't seem to be any benefit}
\sm{this is a trivial but long example. do we really need to this level of detail?}
\input{../content/example-stopwatch}

A more interesting example is presented by \cref{code:cars}. 
\ugh{When no errors result from execution}\sm{what???} the programmer can be sure that a car, 
regardless of which \ugh{method it was made from}\sm{what?}, 
will respond to the ``owner'' and ``changeOwner(\_)'' messages.\sm{why not use the \textbackslash{}code macro for code?}
However, there is no guarantee that the value assigned to the owner field responds to
either the ``name'' (used for people) or ``code'' (used for departments). 

\input{../content/example-cars}

While our design is \ugh{simplistic}\sm{don't say that our design is bad!} in that it examines only the methods to which an object can respond,
rather than the full typing information of the program,
our system is sufficient to verify that a program's execution conforms to \ugh{its documentation}\sm{you never explained what this means. as it is it is way too broad}
and allows the programmer flexibility (the program need not be fully compliant).
Furthermore, as we will continue to describe through \cref{sec:implementation,sec:optimization}, 
our system leads to an easy-to-implement and fast-to-execute implementation.


% \1 multiple types can share an instance
% \1 get from type literals
% \1 add type check nodes to AST
% \1 at run time
%     \2 get type from object layout 
%     \2 get expected type from AST
%     \2 run check


\subsection{Implementation}
\label{sec:implementation}

We implemented our type system as an extension to Moth.
As we described in \cref{ssec:moth},
Moth is an AST-based interpreter
using the Graal just-in-time compiler\citep{Wurthinger:2017:PPE}.

\sm{deep-dive, some high-level summary first before talking about 
anything in a step-wise/procedural way?}
\sm{what are the main components of the implementation?}
\sm{which aspects is this section going to cover?
What am I going to learn?}

Our system first processes all type literals declared in a program and records these as
unique entries into a global record.
When recorded, if a type of the same structure already exists we return the existing instance
rather than creating a new one.
When creating the AST for a program, 
we process any type annotations present on method and variable declarations and
recall the corresponding types from the global record. 
\ugh{Any annotations using the literal syntax constituent adding a new type to the record.}\sm{why does this have to be explained so procedural?
can't we just state that each type literal is an independent type or something?
though, what does this really mean, when do you ``unify'' types?
Is this something that needs to be discussed here?}
Later at run time, we can extract the type of an object from its \ugh{factory 
(a mechanism provided by Moth to instantiate objects)}\sm{do we need to explain this? if so, we need to talk about shapes/maps/hidden classes in background, and we need to explain that this can be applied to classes, too}.
The factory maintains the definitions of the object found during parsing and
we enumerate through this record to obtain a list of names that correspond
to which methods the object can respond too.
We then consult the global record to retrieve an instance of a type object,
which can either create a new object or provide an instance already created.
Finally, we iterate through the list of members defined by the expected type 
(recalled from the AST) and verify that the objects can respond to each one.
We throw an error as soon as an object fails to conform to its expected type, 
and otherwise execution continues unaffected.\sm{but we already said this in the design section, don't we want to say something more specific here?}

An example of the implementation is provided by \cref{code:typecheck}.

\input{../content/example-typecheck}
\sm{what is this? needs an explanation. what is the key idea here?
what part is relevant? what do you want me to take away from it?}



% \1 matrix caching type relationships
%     \2 reducing number of checks
%     \2 example of matrix 

%  \1 specializations depending on values seen at run time
%     \2 null, literals, ...
%     \2 example of type check node w specializations

% \2 compilation at method level
% \2 after inlining, constant prorogation and folding, compilation unit has fewer instructions.

\subsection{Optimization}
\label{sec:optimization}

\sm{let's not say this here if we do not have to, let's say this in the RW section}
From a high level perspective, 
our system is similar to the tag-based system introduced by \citet{Greenman2018}.
The similarity is in this sense that the type of an object is expressed as a reference
to an object in the global record, which
effectively tags each run time object.
\sm{what are the optimizations we do? name them}

We provide two important levels of optimizations for our implementation: 
first, we maintain a three-value matrix that records all known subtyping relationships. 
Whenever we perform a type check, we first examine the matrix to see if the relationship, 
between the type of an object and the expected type, has been computed before.
If already known, the previous result is returned 
or otherwise the relationship is evaluated and the matrix is updated.
\ugh{This optimization alone significantly reduces the overhead}\sm{unsupported claims} of our system 
by eagerly computed each relationship only once whenever it is first required.
\rrtodo{How can I better word next sentence?}
Since objects can share an instance of type,
an check evaluated in one location can eliminate the cost in other locations.
\sm{can we ties this to the explanation in the previous section?}
\sm{can we have an example for a matrix that corresponds to the types used in the previous section?}

\sm{I want to see the type check node, the specialization.
I would like to see an explanation on the level of truffle of how it works,
and based on that we can explain why it works, and why we didn't need much
changes in the interpreter to have this efficient}
\smtodo{Check the following paragraph}
Finally, recall from \cref{ssec:moth} that
Moth's code is compiled using the Graal, 
which performs
constant sub-expression elimination,
method and block inlining,
aggressively propagate and fold constants, and
perform dead code elimination.
Once compiled, much of the computations for type checking
is be folded into method dispatch
(for parameter and return value checks)
and variable reads and assignments.
As we demonstrate later in \cref{sec:evaluation}, 
the overhead of our system is negligible during peak performance.
