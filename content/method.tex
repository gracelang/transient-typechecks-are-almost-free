%!TEX root = ../latex/paper.tex

\section{A Dynamic Type-Checking System}
\label{sec:method}

% evaluation cases

% high flexibility, no need for global constitency 


% design goals behind Grace / Moth
As described in \cref{ssec:grace},
Grace is an educational language and its performance profile
is important for supporting effective teaching. 

% motivation = give students low-overhead method to check program
In this section,
we present a new optional and dynamically checked type system
with a minimal impact on run-time performance.
Following from the design goals behind Grace,
our motivation with the new type system
is to provide developers---and particularly students---with a flexible system 
to check the consistency of the execution of their programs
against type annotations,
without significant impact on run-time performance.

% gradual typing drawback = slow
Gradual typing systems are generally good candidates to achieve this goal.
% Existing gradual typing systems 
% that address the goal of flexibility currently
Unfortunately, they do not yet have the desired performance properties\citep{Takikawa2016}\smtodo{add the other papers}.
Specifically, they could encourage students to remove types
to improve performance.

% % summary of goals
% Instead, the design behind our type system is focused
% on maximizing performance and flexibility while
% preserving the ability for programmers to check the execution
% of their programs.

% % how we address flexible
% To address the goal of flexibility we propose a system that is optional,
% which enables the programmer to benefit from adding checks
% to be performed at run time,
% without the burden of needing to fully type each program.

% how we address min overhead (avoid blame)
% that enables the executed behavior of the program to be checked against
% the documented types without the
% (which leads to significant overhead in previous work).


\subsection{A Shallow Structural Type System}

To achieve the consistency checking with minimal run-time overhead,
we propose a system with shallow structural type checks,
which provide useful feedback without requiring a blame mechanism
as in typical gradually typed approaches.

% Message sending
% As we described in \cref{ssec:grace}, Grace is message-sending-based language.

Specifically, our type system has the following properties:

\begin{itemize}
  \item types are a sets of untyped members,
  \item types are optional and checked eagerly at run time,
        which results in a flexible type system that does not require global
        consistency and complete typing, and
  \item violations of type annotations terminate execution.
\end{itemize}

% Together these properties enable a flexible system
% with minimal overhead
% that developers can use to verify that programs
% execute with values that have the capabilities
% documented through their annotations
% while avoiding the burden of fully typing their program.

We detail these properties
based on a classic student exercise where a student student develops
a program to record information about vehicles.

\paragraph{Types are Sets of Members.}

In our system, a value implements a type when it
can respond to each member of the type.
Thus, a type expresses the capabilities
of an object in terms of the messages an object
can respond to, for example whether a particular accessor is
available, but omits any further typing information of those messages.

Being able to express a set of messages to which an object
must respond is useful. For example, our student can begin
developing its vehicle application
by defining an object
intended to represent a car (\cref{lst:car-reg} \cref{ex:object}) and write a method that, 
given the car object,
returns the registration number (\cref{ex:method}).

\begin{lstlisting}[caption={The start of a simple program for tracking vehicle information.},label=lst:car-reg,escapechar=|]
def car = object {|\label{ex:object}|
    var reg := "JO3553"
}

method getReg(vehicle) {|\label{ex:method}|
    return vehicle.reg
}
\end{lstlisting}

Since the student is still developing the program, 
they may be concerned that the interface of a vehicles will change 
and therefore want to avoid fully typing the program.
Our system supports the student by allowing them to verify
any value passed to the \code{getReg} function will respond
to the \code{reg} message. 


\begin{lstlisting}[caption={Adding a type annotation to a method parameter.},escapechar=|]
method getReg(vehicle: interface { req }) { |\label{ex:adding-type}|
    return vehicle.reg
}
\end{lstlisting}

We can achieve this using a type annotation 
as illustrated in \cref{ex:adding-type}. 
In this case, 
the annotation specifies a type with just one member
corresponding to the \code{reg} message.
\sm{you already said the following}
By adding the type annotation to the program, 
the student can now be sure the \code{getReg} method
will only be invoked when its arguments can respond to this message.
With the assurance that they will be altered when a value 
does not conform to this type,
the student can continue developing the program.

\paragraph{Flexibility.}

The notion of our type system being shallow means 
that members of a type are untyped.
In particular, our design \ugh{ignores typing information}\sm{don't say ignore, just say that our types do not have types for parameters and return types of members}
to avoid the overhead incurred by needing to track assumptions for blame and
also to offer a high level of flexibility.

\begin{lstlisting}[caption={A well-typed but globally inconsistent program.},escapechar=|,label={ex:complex}]
type Car = interface {|\label{ex:complex:car}|
    owner
    changeOwner(_)
}

method newPersonalCar -> Car { |\label{ex:personal-car}|
    object {
        var owner
        method changeOwner(person : interface { name }) { ... } |\label{ex:personal-car:changeOwner}|
    }
}

method newGovernmentCar -> Car { |\label{ex:government-car}|
    object {
        var owner
        method changeOwner(department : interface { code }) { ... } |\label{ex:government-car:changeOwner}|
    }
}

method processPurchase(car: Car, newOwner : Person) { |\label{ex:purchase}|
    car.changeOwner(newOwner)
}
\end{lstlisting}

As a consequence of being shallow our system \ugh{considers programs
well-typed}\sm{no, don't say this. we do not have a notion of well typed programs. We only have a notion of well typed executions. You perhaps want to say this} even when they are globally inconsistent.
For example, in \cref{ex:complex}, the student has defined a type containing
three members and assigned this to the identifier \code{Car} (\cref{ex:complex:car}).
They also introduce two methods to create cars 
(\cref{ex:personal-car,ex:government-car}),
in which both methods are well-typed and indeed return objects that conform to
the \code{Car} type.
However, note that each version of the \code{changeOwner} method
declares a different type for its parameter
(\cref{ex:personal-car:changeOwner,ex:government-car:changeOwner}).
and, consequently, calling the 
\code{processPurchase} method \cref{ex:purchase} with
an object created from the first method would execute as expected
while its with an object created from the second would terminate with
an error. 

\sm{don't say anything about stuff we don't do. this is not really necessary,
and I don't think this is necessarily correct, depending on specific type systems}
A full structural type-checking system would alert the student to 
the inconsistency described above statically,
perhaps displaying an error in their idea. 
While the alert is correct in that their is an inconsistency,
such a system is less flexible. 

\sm{I would just say: possible inconsistency between elements can be approached
step wise, when necessary as the sophistication and completeness of the program improves}
Our system offers a higher level of flexibility in that the student
may still execute the program, 
which may indeed be only partially developed and remain globally inconsistent.
The student may be satisfied that a particular test passes successfully, and
is then free to address the inconsistency in later development.


\paragraph{Termination by Type Error.}

When executing a program without types, there are three possible outcomes.
Either the program (1) terminates successfully,
(2) terminates with an exception, or 
(3) the execution diverges, \ie, it does not terminate.
Using our type system, a
fourth outcome is possible: termination with a typing error.

Provided that the corresponding annotations are present, 
our system will perform a check
on the values of arguments before invoking a method, 
on the value returned by a method after invocation, and
also before any assignment to and read from a variable local to
a method or belonging to an object. 

The checks are performed eagerly%
---as soon as they are encountered during execution---%
and the execution terminate with a typing error 
when a value fails to conform to the expected type.

% Summarize the design section
In summary, our type system enables a developer to express
the capabilities objects throughout different components of 
their programs.
Our representation of types is shallow,
in that a type expresses only the set of members (messages) an object
should respond to while excluding any further typing information. 
With the shallow design we can offer flexibility in the sense that
globally inconsistent programs can still be executed and checked,
which will fail with a typing error when as soon as an value is found
to be inconsistent with a type annotation. 
Overall, our system offers a mechanism to check that a program's execution
is well-typed---%
rather than the program itself being well-typed.
This both lowers overhead for the developer and, 
helps us to avoid the overhead of tracking blame 
as seen among previous works.

\subsection{Implementation} 
\label{ssec:implementation} 


We implemented our type system as an extension to Moth.
As we described in \cref{ssec:moth},
Moth is an AST-based interpreter
using the Graal just-in-time compiler\citep{Wurthinger:2017:PPE}.

\sm{deep-dive, some high-level summary first before talking about 
anything in a step-wise/procedural way?}
\sm{what are the main components of the implementation?}
\sm{which aspects is this section going to cover?
What am I going to learn?}

Our system first processes all type literals declared in a program and records these as
unique entries into a global record.
When recorded, if a type of the same structure already exists we return the existing instance
rather than creating a new one.
When creating the AST for a program, 
we process any type annotations present on method and variable declarations and
recall the corresponding types from the global record. 
\ugh{Any annotations using the literal syntax constituent adding a new type to the record.}\sm{why does this have to be explained so procedural?
can't we just state that each type literal is an independent type or something?
though, what does this really mean, when do you ``unify'' types?
Is this something that needs to be discussed here?}
Later at run time, we can extract the type of an object from its \ugh{factory 
(a mechanism provided by Moth to instantiate objects)}\sm{do we need to explain this? if so, we need to talk about shapes/maps/hidden classes in background, and we need to explain that this can be applied to classes, too}.
The factory maintains the definitions of the object found during parsing and
we enumerate through this record to obtain a list of names that correspond
to which methods the object can respond too.
We then consult the global record to retrieve an instance of a type object,
which can either create a new object or provide an instance already created.
Finally, we iterate through the list of members defined by the expected type 
(recalled from the AST) and verify that the objects can respond to each one.
We throw an error as soon as an object fails to conform to its expected type, 
and otherwise execution continues unaffected.\sm{but we already said this in the design section, don't we want to say something more specific here?}

An example of the implementation is provided by \cref{code:typecheck}.

\input{../content/example-typecheck}
\sm{what is this? needs an explanation. what is the key idea here?
what part is relevant? what do you want me to take away from it?}



% \1 matrix caching type relationships
%     \2 reducing number of checks
%     \2 example of matrix 

%  \1 specializations depending on values seen at run time
%     \2 null, literals, ...
%     \2 example of type check node w specializations

% \2 compilation at method level
% \2 after inlining, constant prorogation and folding, compilation unit has fewer instructions.

\subsection{Optimization}
\label{ssec:optimization}

\sm{what are the optimizations we do? name them}

We provide two important levels of optimizations for our implementation: 
first, we maintain a three-value matrix that records all known subtyping relationships. 
Whenever we perform a type check, we first examine the matrix to see if the relationship, 
between the type of an object and the expected type, has been computed before.
If already known, the previous result is returned 
or otherwise the relationship is evaluated and the matrix is updated.
\ugh{This optimization alone significantly reduces the overhead}\sm{unsupported claims} of our system 
by eagerly computed each relationship only once whenever it is first required.
\rrtodo{How can I better word next sentence?}
Since objects can share an instance of type,
an check evaluated in one location can eliminate the cost in other locations.
\sm{can we ties this to the explanation in the previous section?}
\sm{can we have an example for a matrix that corresponds to the types used in the previous section?}

\sm{I want to see the type check node, the specialization.
I would like to see an explanation on the level of truffle of how it works,
and based on that we can explain why it works, and why we didn't need much
changes in the interpreter to have this efficient}
\smtodo{Check the following paragraph}
Finally, recall from \cref{ssec:moth} that
Moth's code is compiled using the Graal, 
which performs
constant sub-expression elimination,
method and block inlining,
aggressively propagate and fold constants, and
perform dead code elimination.
Once compiled, much of the computations for type checking
is be folded into method dispatch
(for parameter and return value checks)
and variable reads and assignments.
As we demonstrate later in \cref{sec:evaluation}, 
the overhead of our system is negligible during peak performance.
