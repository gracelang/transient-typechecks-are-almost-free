%!TEX root = ../latex/paper.tex

% Breifly recap Grace's type system
As described in \cref{ssec:grace},
Grace's type system is gradual. 
Having the type system be gradual means that types are optional,
allowing the developer to write the program first and add typing information later. 
Grace's type system is also structural, 
which means that typing relationships are evaluated
in terms of how objects behave rather than how they are named. 

% motivation for our system
Unfortunately, providing support for Grace's full system entails a significant amount of work.
An algorithm for the full system would need to extract the type from a given object and then check that
the extracted type is a subtype of expected type (provided by the source code of the program). step through
each signature of the expected type and confirm that the object can respond to corresponding method, 
then check that each of parameters in the signature
(one for each parameters and one for the return type)
match that of the expected method.

\begin{itemize}
\item 
\item examines that the structure 
 and types, and resolve the recursive


Our system provides support for running simple ``responds-to'' checks.
The checks are performed on argument values before a method is invoked,
on the return value after a method finishes, and also
whenever a variables is read from or written
(checking a variable's value when read or the evaluated expression when written).

In this section we describe
how we represent types in the VM,
the notion of a ``responds-to'' check,
when the checks are performed, 
and conclude with detail about our implementation in Moth.

Grace's employs a structural type system,
which means that sub-typing is evaluated on the structure of objects
rather than their names;
most notably,
the consequence of structural typing is that objects who share the same interface
are considered to be the same type.
Since Grace treats methods and fields uniformly (see \cref{overview:grace}), 
we need only consider the public interface of an object for type-checking.

For our dynamic system,
we treat a type as nothing more than a collection of method names
(illustrated by \cref{code:example-type-object}).
We evaluate whether an object conforms to a type
by checking that it can respond to each of the named methods.
Moth has access to the class of any object and
so it is simple to evaluate whether an object conforms to a type by
asking the class if it can respond to each of the method
(see \cref{code:subtyping}.
If an object cannot respond to one of the named methods,
we throw a language level type error
(which may be caught later in the program).
Otherwise we conclude the type check as successful.

\subsection{An Efficient Implementation.}

To obtain the type objects,
we extract the list of method names from each literal defined by the program.
Since any two objects with the same interface are considered to be of the same type,
we create one type object for each unique interface. 
This means we can assign the same instance of type check to multiple type literals
and run time objects;
ultimately reduce the number of type checks that need to be performed.

We also record the sub-typing relations between all instances of types collected by the VM.
We use matrix a three-value truth matrix for this record that 
lists each type object along its row and column (see \cref{fig:sub-typing-matrix}).
We initialize the matrix with true along its trace (each type is a subtype of itself) and 
with the leave the other cells uninitialised.
Whenever a dynamic type check runs we first obtain the type of the object from the VM, 
its expected type from the AST,
and then index the record using these types.

If the corresponding cell is uninitialized
we run the type check and store the result to the table.
When then throw the typing error if the check failed
or otherwise continue with the program execution 
Otherwise, when the corresponding cell already has been assigned a value,
we simply skip the type check and through a type error (when the cell is false)
or continue with execution (when the cell is true).
Using this process we can lazily evaluate each relationship only once.

