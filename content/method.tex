%!TEX root = ../latex/paper.tex

\section{A Dynamic Type-Checking System}
\label{sec:method}

% evaluation cases

% high flexibility, no need for global constitency 


% design goals behind Grace / Moth
As described in \cref{ssec:grace},
Grace is an educational language and its performance profile
is important for supporting effective teaching. 

\mwh{It seems like a \textit{remarkably terrible} idea to be proposing this as a contribution, especially when it's conflated and confused with the performance contributions.}
% motivation = give students low-overhead method to check program
In this section,
we present a system for optional and dynamically checked types
with a minimal impact on run-time performance.
Following from the design goals behind Grace,
our motivation for this work
is to provide developers---and particularly students---with a flexible system 
to check the consistency of the execution of their programs
against type annotations,
without significant impact on run-time performance.
A secondary goal is to have a design that can be implemented with
only a small set of changes to facilitate integration in existing systems.

% gradual typing drawback = slow
Gradual typing systems are generally good candidates to achieve this goal.
% Existing gradual typing systems 
% that address the goal of flexibility currently
Unfortunately, they do not yet have the desired performance properties\citep{Takikawa2016,Vitousek2017,Muehlboeck2017,Bauman2017,Richards2017,Greenman2018}.
Specifically, they could encourage students to remove types
to improve performance.\mwh{This paragraph seems confused to me. They're good, but also they're bad. What is a ``gradual typing system'' here, and how does it relate to ``gradual typing'' and ``type systems'' as separate concepts?}

% % summary of goals
% Instead, the design behind our type system is focused
% on maximizing performance and flexibility while
% preserving the ability for programmers to check the execution
% of their programs.

% % how we address flexible
% To address the goal of flexibility we propose a system that is optional,
% which enables the programmer to benefit from adding checks
% to be performed at run time,
% without the burden of needing to fully type each program.

% how we address min overhead (avoid blame)
% that enables the executed behavior of the program to be checked against
% the documented types without the
% (which leads to significant overhead in previous work).


\subsection{A Shallow Structural Type System}

To achieve the consistency checking with minimal run-time overhead,
we propose a system with shallow structural type checks,
which provide useful feedback without requiring a blame mechanism
as in typical gradually typed approaches.

% Message sending
% As we described in \cref{ssec:grace}, Grace is message-sending-based language.

Specifically, our type system has the following properties:

\begin{itemize}
  \item types are sets of untyped members,
  \item types are optional and checked eagerly at run time,
        which results in a flexible type system that does not require global
        consistency and complete typing, and
  \item violations of type annotations terminate execution.
\end{itemize}

% Together these properties enable a flexible system
% with minimal overhead
% that developers can use to verify that programs
% execute with values that have the capabilities
% documented through their annotations
% while avoiding the burden of fully typing their program.

We detail these properties
based on an exercise where a student develops
a program to record information about vehicles.

\paragraph{Types are Sets of Members.}

In our system, a value implements a type when it
can respond to each member of the type.
Thus, a type expresses the capabilities
of an object in terms of the messages an object
can respond to, for example whether a particular accessor is
available, but omits any further typing information of those messages.

Being able to express a set of messages to which an object
must respond is useful. For example, our student can begin
developing their vehicle application
by defining an object
intended to represent a car (\cref{lst:car-reg}, \cref{ex:object}) and write a method that, 
given the car object,
returns the registration number (\cref{ex:method}).


\begin{lstlisting}[caption={The start of a simple program for tracking vehicle information.},label=lst:car-reg,escapechar=|,float,floatplacement=htbp]
def car = object {|\label{ex:object}|
    var registration := "JO3553"
}

method getRegistration(v) {|\label{ex:method}|
    return v.registration
}
\end{lstlisting}


\begin{lstlisting}[label={ex:vehicle},caption={Adding a type annotation to a method parameter.},escapechar=|,float,floatplacement=htbp]
type Vehicle = interface = { |\label{ex:adding-type:vehicle}|
    registration    
}

method getRegistration(v: Vehicle) { |\label{ex:adding-type}|
    return v.registration
}
\end{lstlisting}

Since the student is still developing the program they 
may wish to avoid fully typing the program,  
for concern that the interface of a vehicle will change soon. 
Our system supports the student by allowing them to verify
that any value passed to the \code{getRegistration} function will respond
to the \code{registration} message.
To get this support the support\mwh{???} adds a type annotation to the method 
as illustrated in \cref{ex:adding-type}. 
In this case, 
the annotation specifies a type with just one member
corresponding to the \code{registration} message.
This gives the student the assurance that they will be alerted when a value 
does not conform to this expected type.

% \sm{you already said the following}
% By adding the type annotation to the program,
% the student can now be sure the \code{getReg} method
% will only be invoked when its arguments can respond to this message.

\paragraph{Flexibility.}

The notion of our type system being shallow means 
that members of a type are untyped.
In particular, our design does not have information on parameter types
and return types for types' members.
This design implies that blame tracking is not needed,\mwh{Um.}
because the types are less detailed than in other systems.\mwh{I would hope that a competent reviewer would't fall for this\ldots}
One reason for this design is that it avoids the overhead incurred
by tracking type assumptions for precise blame attribution.


\begin{lstlisting}[caption={A program in development with a well-typed execution.},escapechar=|,label={ex:complex},float,floatplacement=htb]
type Vehicle = interface = { |\label{ex:new-vehicle}|
    registration
    registerTo(_)
}

type Person = interface { name }
type Department = interface { code }

method personalCar -> Vehicle { |\label{ex:personal-car}|
  object {
    registration
    method registerTo(p: Person) {|\label{ex:personal-car:registerTo}|
      ...
    } 
  }
}

method governmentCar -> Vehicle { |\label{ex:government-car}|
  object {
    registration
    method registerTo(d: Department) { |\label{ex:government-car:registerTo}|
      ...
    }
  }
}

personalCar.registerTo( |\label{ex:invoke-register-to}|
  object {
    var name := "Noble"
  }
)
\end{lstlisting}

Another aspect of this design is
that our shallow approach to types
allows for more flexible use 
without requiring type parameters, \ie, generics.
For example, in \cref{ex:complex}, the student
develops two methods to create cars 
(\cref{ex:personal-car,ex:government-car}),
in which both methods are typed and return objects that conform to
the amended \code{Vehicle} type (\cref{ex:new-vehicle}).
However, note that each version of the \code{registerTo} method
declares a different type for its parameter
(\cref{ex:personal-car:registerTo,ex:government-car:registerTo}).
Depending on its semantics,
a less-shallow type checking system could throw an error
due to the inconsistency.
In contrast
our approach allows the student to execute the program 
despite its inconsistency, 
while preserving the guarantee that any value found to be
inconsistent with the annotation will result in
a termination by a typing error.

% \sm{don't say anything about stuff we don't do. this is not really necessary,
% and I don't think this is necessarily correct, depending on specific type systems}
% A full structural type-checking system would alert the student to
% the inconsistency described above statically,
% perhaps displaying an error in their idea.
% While the alert is correct in that their is an inconsistency,
% such a system is less flexible.

% \sm{I would just say: possible inconsistency between elements can be approached
% step wise, when necessary as the sophistication and completeness of the program improves}
% Our system offers a higher level of flexibility in that the student
% may still execute the program,
% which may indeed be only partially developed and remain globally inconsistent.
% The student may be satisfied that a particular test passes successfully, and
% is then free to address the inconsistency in later development.


\paragraph{Termination by Type Error.}
\label{sec:term-type-error}

When executing a program without types, there are three possible outcomes.
Either the program (1) terminates successfully,
(2) terminates with an exception, or 
(3) the execution diverges, \ie, it does not terminate.
Using our approach, a
fourth outcome is possible: termination with a type error.

Provided that the corresponding annotations are present, 
our system will perform a check
on the values of arguments before invoking a method, 
on the value returned by a method after invocation, and
also before any assignment to and read from a variable 
(either local to a method or belonging to an object). 

The checks are performed eagerly%
---as soon as they are encountered during execution---%
and cause the execution to terminate with a typing error 
when a value fails to implement its expected type.

% Summarize the design section
\paragraph{Summary}
Our type checking approach enables developers to express
the capabilities of objects throughout different components of 
their programs.
Our representation of types is shallow,
in that a type expresses only the set of members (messages) an object
should respond to while excluding any further typing information. 
The shallow design enables a flexible use of structural types without
requiring type parameters.
We abort program execution as soon as
a type annotation is inconsistent with a concrete value. 
With these design choices, our system offers a
mechanism to check for well-typed executions%
---rather than well-typed programs---%
without negatively affectingly the performance profile.
% This both lowers overhead for the developer and,
% helps us to avoid the overhead of tracking blame
% as seen among previous works.

\subsection{Implementation} 
\label{ssec:implementation} 

One of the goals for our approach to dynamic typing was to keep
the necessary changes to an existing implementation small,
while enabling optimization in highly efficient language runtimes.

This section gives an overview of a possible implementation
based on an abstract-syntax-tree (AST) interpreter.

Based on \cref{sec:term-type-error},
our approach needs to check types of values at run-time:

\begin{itemize}
\item the values of arguments are checked, after a method is requested, 
      but before the body of the message is executed,
\item the value returned by a method is checked after its body is executed, and
\item the value of variables are checked
      whenever assigned to or read from by user code.
\end{itemize}

For an AST interpreter,
we can implement this approach by attaching the checks to the relevant AST nodes:
the expected types for the argument and return values can be included
with the node for requesting a method, and the expected type for a variable
can be attached to the nodes for reading from and writing to a method.
In practice,
we encapsulate the logic of the check within a new type-checking AST node
and attach instances of this node as children to the method,
variable read, and variable write nodes. 
The check node is detailed in \cref{ssec:optimization} to discuss relevant
optimizations.

The check node uses the \code{Type} (cf. \cref{ex:type}, \cref{ex:type:check}) to test whether an observed
object conforms to it.
An object satisfies a type, if all members required by the type are provided
by the object (\cref{ex:type:satisfied}).
In addition to the AST node for type checking,
an implementation needs to be adapted to parse and record
the type information in a way that it can be accessed by the
method request, variable read, and variable write nodes.


\begin{lstlisting}[label={ex:type},escapechar=|,caption={Sketch of a \code{Type} in our system and its \code{check()} semantics.},float,floatplacement=htb]
class Type:
  def init(members):
    self._members = members

  def is_satisfied_by(other: Type): |\label{ex:type:satisfied}|
    for m in self._members:
      if not in other._members:
        return False
    return True

  def check(obj: Object):
    t = get_type(obj)
    return self.is_satisfied_by(t) |\label{ex:type:check}|
\end{lstlisting}


\subsection{Optimization}
\label{ssec:optimization}

There are two aspects to our implementation that are critical for a minimal overhead solution. These include:

\begin{itemize}
  \item specialized executions of the type checking node, along with guards to protect these specialized version, and
  \item a matrix to cache sub-typing relationships to eliminate redundant executions.
\end{itemize}

Here we discuss each of the aspects in more detail.

We developed our implementation as an extension to Moth.
As described earlier in \cref{ssec:moth},
Moth is an AST-based interpreter that offers a highly optimized run time.
Moth starts as a standard interpreter but,
using the Graal VM,
is able to optimize itself using profiling information seen at run time. 

\begin{lstlisting}[label={ex:typenode},escapechar=|,caption={An illustration of the type checking node that support type checking},float,floatplacement=htbp]
class TypeCheckNode(Node):

  expected: Type
  cached_shape: Shape
  cached_type: Type
  record: Matrix
  
  def guard(obj: Any): |\label{ex:typenode:guard}|
    if not (obj.shape() != shape or
            cached_type.is_subtype_of(expected)):
      despecialize()

  def check(obj: Number): |\label{ex:typenode:number}|
    guard(obj)

  def check(obj: String): |\label{ex:typenode:string}|
    guard(obj)

  def check(obj: Immutable): |\label{ex:typenode:immut}|
    guard(obj)

  ...

  def check(obj: Object):
    guard(obj)
  
  def check_generic(obj: Any): |\label{ex:typenode:generic}|
    T = get_type(obj)
    
    if record[T, expected] is unknown: |\label{ex:typenode:matrix}|
      record[T, expected] =
          T.is_subtype_of(expected)

    if not record[T, expected]:
      TypeError "{obj} doesn't implement {expected}"
\end{lstlisting}

The first performance-critical aspect to our implementation
is how we specialize the type checking node.
Before specialization,
our node features a generic execution method
(\cref{ex:typenode:generic})
that is responsible for executing the check.
During the first execution of this generic method,
we can see the concrete type of the given object and,
with the support of the Truffle framework,
we are able to redirect future executions of this method
to a more specialized version:
one version to handle primitives like
numbers (\cref{ex:typenode:number}) or strings (\cref{ex:typenode:string}),
another version to handle immutable objects (\cref{ex:typenode:immut}),
and so on.
Each specialized version executes a guard (\cref{ex:typenode:guard})
in place of the type check.
The guard first checks that the shape of the given object
is equal to the shape of the object
used during the first execution.
If the guard fails
we revert back to generic method,
perform the check again,
and then choose a new specialization.
The specialization approach is applicable because
an object's shape implies its type and, therefore,
we are able to replace repeated checks
with a cheap equality check between objects' shapes.

The other performance-critical aspect to our implementation
is the use of a matrix-based record to cache sub-typing relationships.
The matrix compares types against types,
featuring all known types along the columns and the same types again along the rows.
A cell in the table corresponds to a sub-typing relationship:
does the type corresponding to the row implement
the type corresponding to the column?
All cells in the matrix begin as unknown and as 
encountered in a check during execution
we populate the table.
If a particular relationship has been computed before
we can skip the check and instead recall the previously-computed value.
Using this table we are able to eliminate the redundancy of evaluating
the same type to type relationships across different checks in the program. To reduce redundancy further we also unify types.
Our unification of types is similar to Java's string interning; 
during the construction of a type we first check to see if the same
set of members is expressed by a previously-created type and, if so,
we avoid creating the new instance and provide the existing one.

Together the self-specializing type check node and the matrix-based record
ensure that our implementation eliminates redundancy and,
consequently, we are able to minimize the overhead of our system. 

% The Graal compiler 
% Moth needs to query the shape of arguments to evaluate them.
% Moth then needs to query the shape again to run the specializations' guards.
% Once profiled Graal can remove this redundancy by eliminating
% reusing the first query.
% During this compilation Graal also employs other optimizations 
% -- sub-expression elimination, inlining, propagation and folding --\tabularnewline
% and, as we demonstrate next in \cref{sec:evaluation},
% produces a compiled version of the method with minimal overhead incurred from
% the type check.
