%!TEX root = ../latex/paper.tex

\section{A Dynamic Type-Checking System}
\label{sec:method}

% evaluation cases

% high flexibility, no need for global constitency 


% design goals behind Grace / Moth
As described in \cref{ssec:grace},
Grace is an educational language and its performance profile
is important for supporting effective teaching. 

% motivation = give students low-overhead method to check program
In this section,
we present a new optional and dynamically checked type system
with a minimal impact on run-time performance.
Following from the design goals behind Grace,
our motivation with the new type system
is to provide developers---and particularly students---with a flexible system 
to check the consistency of the execution of their programs
against type annotations,
without significant impact on run-time performance.

% gradual typing drawback = slow
Gradual typing systems are generally good candidates to achieve this goal.
% Existing gradual typing systems 
% that address the goal of flexibility currently
Unfortunately, they do not yet have the desired performance properties\citep{Takikawa2016}\smtodo{add the other papers}.
Specifically, they could encourage students to remove types
to improve performance.

% % summary of goals
% Instead, the design behind our type system is focused
% on maximizing performance and flexibility while
% preserving the ability for programmers to check the execution
% of their programs.

% % how we address flexible
% To address the goal of flexibility we propose a system that is optional,
% which enables the programmer to benefit from adding checks
% to be performed at run time,
% without the burden of needing to fully type each program.

% how we address min overhead (avoid blame)
To achieve the consistency checking with minimal run-time overhead,
we propose shallow structural type checks,
% that enables the executed behavior of the program to be checked against
% the documented types without the
which provide useful feedback without requiring a blame mechanism
as in typical gradually typed approaches.
% (which leads to significant overhead in previous work).


\subsection{A Shallow Structural Type System}

% Message sending
% As we described in \cref{ssec:grace}, Grace is message-sending-based language.

Our type system has the following properties:

\begin{itemize}
    \item it poses types as sets of untyped members,
    \item it adds one further termination condition to execution, and 
    \item is flexible in that programs need not be globally consistent to run.
\end{itemize}

Together these properties enable a flexible system
with minimal overhead
that developers can use to verify that programs 
execute with values that have the capabilities 
documented through their annotations 
while avoiding the burden of fully typing their program. 

We now introduce each of these properties in more detail
using a running example where a student develops
a program that records information about vehicles; 
before continuing to outline
our implementation (\cref{ssec:implementation})
and its optimization (\cref{ssec:optimization}).

\paragraph{Types are Sets of Members}

In our system, a value implements a type when it
can respond to each member of that type's interface.
With this abstraction a type can express the capabilities
of an object in terms of what messages the object can respond to 
-- such as whether or not an particular accessors is available
or if the object has a print method defined --
but omits any further typing information of those messages.

Being able to express a set of messages to which an object
must respond is a useful abstraction. For example, 
say a student has started developing a program for recording
information about vehicles. They begin by defining an object
intended to represent a car (\cref{ex:object}) and write a method that, 
given the car object,
returns the registration number (\cref{ex:method}).

\begin{lstlisting}[caption={An object literal with a field named ``reg'' and assigns it to the ``car'' variable.},escapechar=|]
def car = object {|\label{ex:object}|
    var reg
}

method getReg(vehicle) { |\label{ex:method}|
    return vehicle.reg
}
\end{lstlisting}

Since the student is still developing the program, 
they are concerned that the interface used for vehicles might change 
and so wish to avoiding fully typing the program.
To help the student in this case, 
our system


 a type expresses that 
that is, the set of messages to which an object can respond.

As an example imagine  
Currently, the student only has one example to work with (see \cref{ex:object}).
The student wishes to develop the method,
without needing to think carefully about abstraction,
while having some security that their program
performs they expected.



With our system, the student can develop implement the method and 
obtain security by adding an annotation to its parameter. 
In \cref{ex:method}, the annotation
-- the keyword ``interface'' followed by a list of signatures enclosed with curly-braces --
states the argument must respond to at least the ``reg'' message. 

\begin{lstlisting}[label={ex:method},caption={A method with its argument annotated with an interface literal, stating that the value must respond to at least the ``reg'' message.}]

\end{lstlisting}

When executing this method at run time
our system will process the annotation,
before the method is executed,
and verify that the value provided for the ``vehicle'' argument 
can respond to the ``reg'' message.
In the case when the value does not implement the ``reg'' member,
the system will terminate with a typing error 
that alerts the student to an inconsistency between the
execution of the program and its type annotations.



Following Grace's syntax, our system processes type annotations when attached
to both a method's parameters and return types. 

\subsection{Implementation} 
\label{ssec:implementation} 


We implemented our type system as an extension to Moth.
As we described in \cref{ssec:moth},
Moth is an AST-based interpreter
using the Graal just-in-time compiler\citep{Wurthinger:2017:PPE}.

\sm{deep-dive, some high-level summary first before talking about 
anything in a step-wise/procedural way?}
\sm{what are the main components of the implementation?}
\sm{which aspects is this section going to cover?
What am I going to learn?}

Our system first processes all type literals declared in a program and records these as
unique entries into a global record.
When recorded, if a type of the same structure already exists we return the existing instance
rather than creating a new one.
When creating the AST for a program, 
we process any type annotations present on method and variable declarations and
recall the corresponding types from the global record. 
\ugh{Any annotations using the literal syntax constituent adding a new type to the record.}\sm{why does this have to be explained so procedural?
can't we just state that each type literal is an independent type or something?
though, what does this really mean, when do you ``unify'' types?
Is this something that needs to be discussed here?}
Later at run time, we can extract the type of an object from its \ugh{factory 
(a mechanism provided by Moth to instantiate objects)}\sm{do we need to explain this? if so, we need to talk about shapes/maps/hidden classes in background, and we need to explain that this can be applied to classes, too}.
The factory maintains the definitions of the object found during parsing and
we enumerate through this record to obtain a list of names that correspond
to which methods the object can respond too.
We then consult the global record to retrieve an instance of a type object,
which can either create a new object or provide an instance already created.
Finally, we iterate through the list of members defined by the expected type 
(recalled from the AST) and verify that the objects can respond to each one.
We throw an error as soon as an object fails to conform to its expected type, 
and otherwise execution continues unaffected.\sm{but we already said this in the design section, don't we want to say something more specific here?}

An example of the implementation is provided by \cref{code:typecheck}.

\input{../content/example-typecheck}
\sm{what is this? needs an explanation. what is the key idea here?
what part is relevant? what do you want me to take away from it?}



% \1 matrix caching type relationships
%     \2 reducing number of checks
%     \2 example of matrix 

%  \1 specializations depending on values seen at run time
%     \2 null, literals, ...
%     \2 example of type check node w specializations

% \2 compilation at method level
% \2 after inlining, constant prorogation and folding, compilation unit has fewer instructions.

\subsection{Optimization}
\label{ssec:optimization}

\sm{let's not say this here if we do not have to, let's say this in the RW section}
From a high level perspective, 
our system is similar to the tag-based system introduced by \citet{Greenman2018}.
The similarity is in this sense that the type of an object is expressed as a reference
to an object in the global record, which
effectively tags each run time object.
\sm{what are the optimizations we do? name them}

We provide two important levels of optimizations for our implementation: 
first, we maintain a three-value matrix that records all known subtyping relationships. 
Whenever we perform a type check, we first examine the matrix to see if the relationship, 
between the type of an object and the expected type, has been computed before.
If already known, the previous result is returned 
or otherwise the relationship is evaluated and the matrix is updated.
\ugh{This optimization alone significantly reduces the overhead}\sm{unsupported claims} of our system 
by eagerly computed each relationship only once whenever it is first required.
\rrtodo{How can I better word next sentence?}
Since objects can share an instance of type,
an check evaluated in one location can eliminate the cost in other locations.
\sm{can we ties this to the explanation in the previous section?}
\sm{can we have an example for a matrix that corresponds to the types used in the previous section?}

\sm{I want to see the type check node, the specialization.
I would like to see an explanation on the level of truffle of how it works,
and based on that we can explain why it works, and why we didn't need much
changes in the interpreter to have this efficient}
\smtodo{Check the following paragraph}
Finally, recall from \cref{ssec:moth} that
Moth's code is compiled using the Graal, 
which performs
constant sub-expression elimination,
method and block inlining,
aggressively propagate and fold constants, and
perform dead code elimination.
Once compiled, much of the computations for type checking
is be folded into method dispatch
(for parameter and return value checks)
and variable reads and assignments.
As we demonstrate later in \cref{sec:evaluation}, 
the overhead of our system is negligible during peak performance.
