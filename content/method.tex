%!TEX root = ../latex/paper.tex

\section{A Dynamic Type-Checking System}
\label{sec:method}

% evaluation cases

% high flexibility, no need for global constitency 


% design goals behind Grace / Moth
As described in \cref{ssec:grace},
Grace is an educational language and its performance profile
is important for supporting effective teaching. 

% motivation = give students low-overhead method to check program
In this section,
we present a new optional and dynamically checked type system
with a minimal impact on run-time performance.
Following from the design goals behind Grace,
our motivation with the new type system
is to provide developers---and particularly students---with a flexible system 
to check the consistency of the execution of their programs
against type annotations,
without significant impact on run-time performance.

% gradual typing drawback = slow
Gradual typing systems are generally good candidates to achieve this goal.
% Existing gradual typing systems 
% that address the goal of flexibility currently
Unfortunately, they do not yet have the desired performance properties\citep{Takikawa2016}\smtodo{add the other papers}.
Specifically, they could encourage students to remove types
to improve performance.

% % summary of goals
% Instead, the design behind our type system is focused
% on maximizing performance and flexibility while
% preserving the ability for programmers to check the execution
% of their programs.

% % how we address flexible
% To address the goal of flexibility we propose a system that is optional,
% which enables the programmer to benefit from adding checks
% to be performed at run time,
% without the burden of needing to fully type each program.

% how we address min overhead (avoid blame)
% that enables the executed behavior of the program to be checked against
% the documented types without the
% (which leads to significant overhead in previous work).


\subsection{A Shallow Structural Type System}

To achieve the consistency checking with minimal run-time overhead,
we propose a system with shallow structural type checks,
which provide useful feedback without requiring a blame mechanism
as in typical gradually typed approaches.

% Message sending
% As we described in \cref{ssec:grace}, Grace is message-sending-based language.

Specifically, our type system has the following properties:

\begin{itemize}
  \item types are a sets of untyped members,
  \item types are optional and checked eagerly at run time,
        which results in a flexible type system that does not require global
        consistency and complete typing, and
  \item violations of type annotations terminate execution.
\end{itemize}

% Together these properties enable a flexible system
% with minimal overhead
% that developers can use to verify that programs
% execute with values that have the capabilities
% documented through their annotations
% while avoiding the burden of fully typing their program.

We detail these properties
based on a classic student exercise where a student student develops
a program to record information about vehicles.

\paragraph{Types are Sets of Members.}

In our system, a value implements a type when it
can respond to each member of the type.
Thus, a type expresses the capabilities
of an object in terms of the messages an object
can respond to, for example whether a particular accessor is
available, but omits any further typing information of those messages.

Being able to express a set of messages to which an object
must respond is useful. For example, our student can begin
developing its vehicle application
by defining an object
intended to represent a car (\cref{lst:car-reg} \cref{ex:object}) and write a method that, 
given the car object,
returns the registration number (\cref{ex:method}).

\begin{lstlisting}[caption={The start of a simple program for tracking vehicle information.},label=lst:car-reg,escapechar=|]
def car = object {|\label{ex:object}|
    var reg := "JO3553"
}

method getReg(v) {|\label{ex:method}|
    return v.reg
}
\end{lstlisting}

Since the student is still developing the program, 
they may be concerned that the interface of a vehicles will change 
and therefore want to avoid fully typing the program.
Our system supports the student by allowing them to verify
any value passed to the \code{getReg} function will respond
to the \code{reg} message. 

\begin{lstlisting}[caption={Adding a type annotation to a method parameter.},escapechar=|]
type Vehicle = interface = {
    reg    
}

method getReg(v: Vehicle) { |\label{ex:adding-type}|
    return v.reg
}
\end{lstlisting}

We can achieve this using a type annotation 
as illustrated in \cref{ex:adding-type}. 
In this case, 
the annotation specifies a type with just one member
corresponding to the \code{reg} message.
\sm{you already said the following}
By adding the type annotation to the program, 
the student can now be sure the \code{getReg} method
will only be invoked when its arguments can respond to this message.
With the assurance that they will be altered when a value 
does not conform to this type,
the student can continue developing the program.

\paragraph{Flexibility.}

The notion of our type system being shallow means 
that members of a type are untyped.
In particular, our design \ugh{ignores typing information}\sm{don't say ignore, just say that our types do not have types for parameters and return types of members}
to avoid the overhead incurred by needing to track assumptions for blame and
also to offer a high level of flexibility.

\begin{lstlisting}[caption={A well-typed but globally inconsistent program.},escapechar=|,label={ex:complex}]
type Person = interface {
  name
}

method makePersonalCar -> Car { |\label{ex:personal-car}|
  object {
    method registerTo(p: Person) {|\label{ex:personal-car:changeOwner}|
      ...
    } 
  }
}

type Department = interface {
  code
}

method makeGovernmentCar -> Car { |\label{ex:government-car}|
  object {
    method registerTo(d: Department) { |\label{ex:government-car:changeOwner}|
      ...
    }
  }
}

method purchase(c: Car, p: Person) { |\label{ex:purchase}|
  c.registerTo(p)
}
\end{lstlisting}

As a consequence of being shallow our system \ugh{considers programs
well-typed}\sm{no, don't say this. we do not have a notion of well typed programs. We only have a notion of well typed executions. You perhaps want to say this} even when they are globally inconsistent.
For example, in \cref{ex:complex}, the student has defined a type containing
three members and assigned this to the identifier \code{Car} (\cref{ex:complex:car}).
They also introduce two methods to create cars 
(\cref{ex:personal-car,ex:government-car}),
in which both methods are well-typed and indeed return objects that conform to
the \code{Car} type.
However, note that each version of the \code{changeOwner} method
declares a different type for its parameter
(\cref{ex:personal-car:changeOwner,ex:government-car:changeOwner}).
and, consequently, calling the 
\code{processPurchase} method \cref{ex:purchase} with
an object created from the first method would execute as expected
while its with an object created from the second would terminate with
an error. 

\sm{don't say anything about stuff we don't do. this is not really necessary,
and I don't think this is necessarily correct, depending on specific type systems}
A full structural type-checking system would alert the student to 
the inconsistency described above statically,
perhaps displaying an error in their idea. 
While the alert is correct in that their is an inconsistency,
such a system is less flexible. 

\sm{I would just say: possible inconsistency between elements can be approached
step wise, when necessary as the sophistication and completeness of the program improves}
Our system offers a higher level of flexibility in that the student
may still execute the program, 
which may indeed be only partially developed and remain globally inconsistent.
The student may be satisfied that a particular test passes successfully, and
is then free to address the inconsistency in later development.


\paragraph{Termination by Type Error.}

When executing a program without types, there are three possible outcomes.
Either the program (1) terminates successfully,
(2) terminates with an exception, or 
(3) the execution diverges, \ie, it does not terminate.
Using our type system, a
fourth outcome is possible: termination with a typing error.

Provided that the corresponding annotations are present, 
our system will perform a check
on the values of arguments before invoking a method, 
on the value returned by a method after invocation, and
also before any assignment to and read from a variable local to
a method or belonging to an object. 

The checks are performed eagerly%
---as soon as they are encountered during execution---%
and the execution terminate with a typing error 
when a value fails to conform to the expected type.

% Summarize the design section
In summary, our type system enables a developer to express
the capabilities objects throughout different components of 
their programs.
Our representation of types is shallow,
in that a type expresses only the set of members (messages) an object
should respond to while excluding any further typing information. 
With the shallow design we can offer flexibility in the sense that
globally inconsistent programs can still be executed and checked,
which will fail with a typing error when as soon as an value is found
to be inconsistent with a type annotation. 
Overall, our system offers a mechanism to check that a program's execution
is well-typed---%
rather than the program itself being well-typed.
This both lowers overhead for the developer and, 
helps us to avoid the overhead of tracking blame 
as seen among previous works.

\subsection{Implementation} 
\label{ssec:implementation} 

% starting from AST interpreter we need checks here, here, and here

% first add knowledge of all types, can be recalled
% new type check node
%     child on other nodes (method has n children, var read and write have one)

% semantics for type check


Our approach performs checks at during different run time events:

\begin{itemize}
\item the values of arguments are checked, after a method is requested, 
      but before the body of the message is executed,
\item the value returned by a method is checked after its body is executed, and
\item the value of variables are checked whenever assigned to or read from.
\end{itemize}

Starting from an AST interpreter,
we can implement support for approach by attaching the checks to AST nodes:
the expected types for the argument and return values can be included
with the node for requesting a method, and the expected type for a variable
can be attached to the nodes for reading from and writing to a method.
In practice,
we encapsulate the logic of the check within a new type-checking AST node
-- illustrated by \cref{ex:typecheck} --
and attach instances of this node as children to the method,
variable read, and variable write nodes. 
The AST node implements the algorithm to evaluate whether a given object
conforms to the expected type.
When executed the node first obtains the type of the given object by
collecting the messages it can respond to into a set,
which is used to form a new type node (\cref{ex:typenode:reflect}).
The relationship between the type of the object and the expected type can
then be evaluated using a standard superset operation (\cref{ex:typenode:superset}).
With the AST node for type checking in place 
we need only extract the definitions of types during parsing 
and record these into global record that can be recalled by the
dispatch, variable read, and variable write nodes.


\begin{lstlisting}[label={ex:typenode},escapechar=|,caption={An illustration of the AST node that we use to perform type checks},float,floatplacement=htbp]
class Type:

    def is_subtype_of(other: Type):
      s =  self._members
      t = other._members
      return s.issuperset(t) |\label{ex:typenode:superset}|

    def is_object_subtype(other: Object):
      type = Type(reflect_members(other)) |\label{ex:typenode:reflect}|
      return type.is_subtype_of(self)

\end{lstlisting}


In summary, our type checking can be realized with a light-weight implementation: 
information about the expected types needs to be attached to the AST and, 
with that information available,
the checks can be implemented using standard reflection and set operations. While sets and their operations are provided as primitives in most languages, support for reflection, 
which we require to collect the set of messages to which an object can respond,
can vary. Next in \cref{ssec:optimization} we describe how we were able to realize a fast implementation using the Moth interpreter for Grace.


% \1 matrix caching type relationships
%     \2 reducing number of checks
%     \2 example of matrix 

%  \1 specializations depending on values seen at run time
%     \2 null, literals, ...
%     \2 example of type check node w specializations

% \2 compilation at method level
% \2 after inlining, constant prorogation and folding, compilation unit has fewer instructions.

\subsection{Optimization}
\label{ssec:optimization}

% type unification
% matrix
% specialization
% graal stuff

\sm{what are the optimizations we do? name them}

We provide two important levels of optimizations for our implementation: 
first, we maintain a three-value matrix that records all known subtyping relationships. 
Whenever we perform a type check, we first examine the matrix to see if the relationship, 
between the type of an object and the expected type, has been computed before.
If already known, the previous result is returned 
or otherwise the relationship is evaluated and the matrix is updated.
\ugh{This optimization alone significantly reduces the overhead}\sm{unsupported claims} of our system 
by eagerly computed each relationship only once whenever it is first required.
\rrtodo{How can I better word next sentence?}
Since objects can share an instance of type,
an check evaluated in one location can eliminate the cost in other locations.
\sm{can we ties this to the explanation in the previous section?}
\sm{can we have an example for a matrix that corresponds to the types used in the previous section?}

\sm{I want to see the type check node, the specialization.
I would like to see an explanation on the level of truffle of how it works,
and based on that we can explain why it works, and why we didn't need much
changes in the interpreter to have this efficient}
\smtodo{Check the following paragraph}
Finally, recall from \cref{ssec:moth} that
Moth's code is compiled using the Graal, 
which performs
constant sub-expression elimination,
method and block inlining,
aggressively propagate and fold constants, and
perform dead code elimination.
Once compiled, much of the computations for type checking
is be folded into method dispatch
(for parameter and return value checks)
and variable reads and assignments.
As we demonstrate later in \cref{sec:evaluation}, 
the overhead of our system is negligible during peak performance.
