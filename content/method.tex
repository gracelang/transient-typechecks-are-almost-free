%!TEX root = ../latex/paper.tex

\section{A Dynamic Type-Checking System}
\label{sec:method}

% evaluation cases

% high flexibility, no need for global constitency 


% design goals behind Grace / Moth
As described in \cref{ssec:grace},
Grace is an educational language and its performance profile
is important for supporting effective teaching. 

% motivation = give students low-overhead method to check program
In this section,
we present a system for optional and dynamically checked types
with a minimal impact on run-time performance.
Following from the design goals behind Grace,
our motivation for this work
is to provide developers---and particularly students---with a flexible system 
to check the consistency of the execution of their programs
against type annotations,
without significant impact on run-time performance.
A secondary goal is to have a design that can be implemented with
only a small set of changes to facilitate integration in existing systems.

% gradual typing drawback = slow
Gradual typing systems are generally good candidates to achieve this goal.
% Existing gradual typing systems 
% that address the goal of flexibility currently
Unfortunately, they do not yet have the desired performance properties\citep{Takikawa2016,Vitousek2017,Muehlboeck2017,Bauman2017,Richards2017,Greenman2018}.
Specifically, they could encourage students to remove types
to improve performance.

% % summary of goals
% Instead, the design behind our type system is focused
% on maximizing performance and flexibility while
% preserving the ability for programmers to check the execution
% of their programs.

% % how we address flexible
% To address the goal of flexibility we propose a system that is optional,
% which enables the programmer to benefit from adding checks
% to be performed at run time,
% without the burden of needing to fully type each program.

% how we address min overhead (avoid blame)
% that enables the executed behavior of the program to be checked against
% the documented types without the
% (which leads to significant overhead in previous work).


\subsection{A Shallow Structural Type System}

To achieve the consistency checking with minimal run-time overhead,
we propose a system with shallow structural type checks,
which provide useful feedback without requiring a blame mechanism
as in typical gradually typed approaches.

% Message sending
% As we described in \cref{ssec:grace}, Grace is message-sending-based language.

Specifically, our type system has the following properties:

\begin{itemize}
  \item types are a sets of untyped members,
  \item types are optional and checked eagerly at run time,
        which results in a flexible type system that does not require global
        consistency and complete typing, and
  \item violations of type annotations terminate execution.
\end{itemize}

% Together these properties enable a flexible system
% with minimal overhead
% that developers can use to verify that programs
% execute with values that have the capabilities
% documented through their annotations
% while avoiding the burden of fully typing their program.

We detail these properties
based on a classic student exercise where a student develops
a program to record information about vehicles.

\paragraph{Types are Sets of Members.}

In our system, a value implements a type when it
can respond to each member of the type.
Thus, a type expresses the capabilities
of an object in terms of the messages an object
can respond to, for example whether a particular accessor is
available, but omits any further typing information of those messages.

Being able to express a set of messages to which an object
must respond is useful. For example, our student can begin
developing their vehicle application
by defining an object
intended to represent a car (\cref{lst:car-reg} \cref{ex:object}) and write a method that, 
given the car object,
returns the registration number (\cref{ex:method}).


\begin{lstlisting}[caption={The start of a simple program for tracking vehicle information.},label=lst:car-reg,escapechar=|,float,floatplacement=htbp]
def car = object {|\label{ex:object}|
    var registration := "JO3553"
}

method getRegistration(v) {|\label{ex:method}|
    return v.registration
}
\end{lstlisting}

Since the student is still developing the program, 
they may be concerned that the interface of a vehicles will change 
and therefore want to avoid fully typing the program.
Our system supports the student by allowing them to verify
that any value passed to the \code{getRegistration} function will respond
to the \code{registration} message. 


\begin{lstlisting}[caption={Adding a type annotation to a method parameter.},escapechar=|,float,floatplacement=htbp]
type Vehicle = interface = {
    registration    
}

method getRegistration(v: Vehicle) { |\label{ex:adding-type}|
    return v.registration
}
\end{lstlisting}

We can achieve this using a type annotation 
as illustrated in \cref{ex:adding-type}. 
In this case, 
the annotation specifies a type with just one member
corresponding to the \code{registration} message.
% \sm{you already said the following}
% By adding the type annotation to the program,
% the student can now be sure the \code{getReg} method
% will only be invoked when its arguments can respond to this message.
This gives the student the assurance that they will be alerted when a value 
does not conform to this expected type.

\paragraph{Flexibility.}

The notion of our type system being shallow means 
that members of a type are untyped.
In particular, our design does not have information on parameter types
and return types for the type members.
This design implies that blame tracking is not needed,
because the types are less detailed than in other systems.
One reason for this design is that it avoid the overhead incurred
by tracking type assumptions for precise blame attribution.


\begin{lstlisting}[caption={A globally inconsistent program that has a well-typed execution.},escapechar=|,label={ex:complex},float,floatplacement=htb]
type Person = interface { name }
type Department = interface { code }

method personalCar -> Car { |\label{ex:personal-car}|
  object {
    method registerTo(p: Person) {|\label{ex:personal-car:registerTo}|
      ...
    } 
  }
}

method governmentCar -> Car { |\label{ex:government-car}|
  object {
    method registerTo(d: Department) { |\label{ex:government-car:registerTo}|
      ...
    }
  }
}

car.registerTo(
  object {
    var name := "Noble"
  }
)
\end{lstlisting}

Another aspect of this design is
that our shallow approach to types
allows for a more flexible use of these structural types
without requiring type parameters, \ie, generics.
For example, in \cref{ex:complex}, the student defined a type containing
three members and assigned this to the identifier \code{Car} (\cref{ex:complex:car}).\sm{there is no car type???}
They also add two methods to create cars 
(\cref{ex:personal-car,ex:government-car}),
in which both methods are typed and return objects that conform to
the \code{Car} type.
However, note that each version of the \code{registerTo} method
declares a different type for its parameter
(\cref{ex:personal-car:registerTo,ex:government-car:registerTo}).
and, consequently, calling the 
\code{processPurchase} method \cref{ex:purchase} with
an object created from the first method would execute as expected
while its with an object created from the second would terminate with
an error. \sm{this inconsistent, these elements don't exist! is this unchanged after a revision???}

% \sm{don't say anything about stuff we don't do. this is not really necessary,
% and I don't think this is necessarily correct, depending on specific type systems}
% A full structural type-checking system would alert the student to
% the inconsistency described above statically,
% perhaps displaying an error in their idea.
% While the alert is correct in that their is an inconsistency,
% such a system is less flexible.

% \sm{I would just say: possible inconsistency between elements can be approached
% step wise, when necessary as the sophistication and completeness of the program improves}
% Our system offers a higher level of flexibility in that the student
% may still execute the program,
% which may indeed be only partially developed and remain globally inconsistent.
% The student may be satisfied that a particular test passes successfully, and
% is then free to address the inconsistency in later development.


\paragraph{Termination by Type Error.}

When executing a program without types, there are three possible outcomes.
Either the program (1) terminates successfully,
(2) terminates with an exception, or 
(3) the execution diverges, \ie, it does not terminate.
Using our approach, a
fourth outcome is possible: termination with a type error.

Provided that the corresponding annotations are present, 
our system will perform a check
on the values of arguments before invoking a method, 
on the value returned by a method after invocation, and
also before any assignment to and read from a variable local to
a method or belonging to an object. 

The checks are performed eagerly%
---as soon as they are encountered during execution---%
and the execution terminate with a typing error 
when a value fails to conform to the expected type.

% Summarize the design section
\paragraph{Summary}
Our type checking approach enables developers to express
the capabilities of objects throughout different components of 
their programs.
Our representation of types is shallow,
in that a type expresses only the set of members (messages) an object
should respond to while excluding any further typing information. 
The shallow design enables a flexible use of structural types without
requiring type parameters.
We abort program execution as soon as
a type annotation is inconsistent with a concrete value. 
With these design choices, our system offers a mechanism to check that a program's execution
is well-typed---%
rather than the program itself being well-typed.
% This both lowers overhead for the developer and,
% helps us to avoid the overhead of tracking blame
% as seen among previous works.

\subsection{Implementation} 
\label{ssec:implementation} 

% starting from AST interpreter we need checks here, here, and here

% first add knowledge of all types, can be recalled
% new type check node
%     child on other nodes (method has n children, var read and write have one)

% semantics for type check


Our approach performs checks at during different run time events:

\begin{itemize}
\item the values of arguments are checked, after a method is requested, 
      but before the body of the message is executed,
\item the value returned by a method is checked after its body is executed, and
\item the value of variables are checked whenever assigned to or read from.
\end{itemize}

Starting from an AST interpreter,
we can implement support for approach by attaching the checks to AST nodes:
the expected types for the argument and return values can be included
with the node for requesting a method, and the expected type for a variable
can be attached to the nodes for reading from and writing to a method.
In practice,
we encapsulate the logic of the check within a new type-checking AST node
-- illustrated by \cref{ex:typenode} --
and attach instances of this node as children to the method,
variable read, and variable write nodes. 
The AST node implements the algorithm to evaluate whether a given object
conforms to the expected type.
When executed the node first obtains the type of the given object by
collecting the messages it can respond to into a set,
which is used to form a new type node (\cref{ex:typenode:check}).
The relationship between the type of the object and the expected type can
then be evaluated using a standard superset operation (\cref{ex:typenode:superset}).
With the AST node for type checking in place 
we need only extract the definitions of types during parsing 
and record these into global record that can be recalled by the
dispatch, variable read, and variable write nodes.


\begin{lstlisting}[label={ex:typenode},escapechar=|,caption={An illustration of the AST node that we use to perform type checks},float,floatplacement=htbp]
class Type:

    def is_subtype_of(other: Type):
      s =  self._members
      t = other._members
      return s.issuperset(t) |\label{ex:typenode:superset}|

    def is_object_subtype(obj: Object):
      return Type(obj.members.is_subtype_of(self) |\label{ex:typenode:check}|

\end{lstlisting}


In summary, our type checking can be realized with a light-weight implementation: 
information about the expected types needs to be attached to the AST and, 
with that information available,
the checks can be implemented using standard set operations.


\subsection{Optimization}
\label{ssec:optimization}

There are two aspects to our implementation that are critical for a minimal overhead solution. These include:

\begin{itemize}
  \item specialization of the type checking node and shape-based guards for the specialization, and
  \item a matrix to cache sub-typing relationships and unification of types.
\end{itemize}

Here we discuss each of the aspects in more detail.

We developed our implementation as an extension to Moth.
As described earlier in \cref{ssec:moth}),
Moth is an AST-based interpreter that offers a highly optimized run time.
Moth starts as a standard interpreter but,
using the Graal VM,
is able to optimize itself using profiling information seen at run time. 

The first performance-critical aspect to our implementation
is how we specialize the type checking node.
Before specialization,
our node features a generic execution method
that first collects the set of members
from the given object and performs the superset operation
to verify that it conforms to its expected type
(recall the illustration from \cref{ex:typenode},
\cref{ex:typenode:superset}).
However, during the first execution of this generic method,
we can see the concrete type of the given object and,
in many cases,
we can redirect future executions of this method to a more specialized version:
one version to handle primitives like numbers or strings,
another version to handle immutable objects,
another to handle objects without fields,
and so on.
Whenever the execution is redirected in this way,
we attach a guard that must be verified before the specialized version can be executed.
The guard states that the shape of the given object
-- a typical VM representation of an object's memory layout --
must be equal to the shape of the object
used in the first execution.
If the guard fails,
we return to the generic method and choose a new specialization.
Since an object's shape implies its type,
we are able to reduce overhead
by replacing the repeated checks
with a simple reference equality operation.

The other performance-critical aspect to our implementation
is the use of a matrix-based record to cache sub-typing relationships.
The matrix compares types against types,
featuring all known types along the columns and the same types again along the rows.
A cell in table corresponds to a sub-typing relationship:
is the type corresponding to the row conform a subtype of the type corresponding to the column?
We first created, all cells in the matrix assigned an unknown (null) value.
Whenever we perform a type check during the execution of our program we 
first consult this table
-- if the result is known, we simply return the value assigned to that cell --
and otherwise we perform the check, via the superset operation,
and assign the resulting boolean value to the table.
Using this table means that we perform each unique type check only once.
While the number of cells in the table can grow quickly,
many of them are unlikely to be visited. 
Consequently, a sparse-matrix implementation can be used to reduce memory overhead.
Finally,
we unify instances of types to help reduce the number of potential sub-typing checks.
Our unification of types is similar to Java's string interning; 
during construction of a type,
we check to see if the same set of members is held
by an existing type and, if so,
we we avoid creating another instance and instead
provide the existing one.

Together the self-specializing type check node and the matrix-based record
ensure that our implementation features minimal overhead. 
In particular, using an object's shapes
to protect specialized versions of the type check node 
means that the Graal compiler can eliminate redundancy. For example,
Moth needs to query the shape of arguments to evaluate them.
Moth then needs to query the shape again to run the specializations' guards.
Once profiled Graal can remove this redundancy by eliminating
reusing the first query.
During this compilation Graal also employs other optimizations 
-- sub-expression elimination, inlining, propagation and folding --\tabularnewline
and, as we demonstrate next in \cref{sec:evaluation},
produces a compiled version of the method with minimal overhead incurred from
the type check.
