%!TEX root = ../latex/paper.tex

\section{Simple Dynamic Type Checking}
\label{sec:method}

% Breifly recap Grace's type system
As described in \cref{ssec:grace},
Grace's type system is gradual. 
Having the type system be gradual means that types are optional,
allowing the developer to write the program first and add typing information later. 
Grace's type system is also structural, 
which means that typing relationships are evaluated
in terms of how objects behave rather than how they are named. 

% The full system
Unfortunately, providing support for Grace's full system entails a significant amount of work.
An algorithm for the full system would need to 
first extract the type from a given object 
and then check that the extracted type is a subtype of expected type 
-- the expected type is expressed through an  annotation in the source program
(see \cref{code:grace-annotation}).
The check itself involves evaluating
whether the object implements each of the methods declared by expected type.
In turn, this evaluation involves determining that the object can respond to the given method and;
furthermore, that both the expected method and the object's method have the same parameter and return types.
The notion of gradual typing complicates the issue,
since some of the typing information is unknown when the program is parsed. 
When faced with an unknown case,
the algorithm must allow that part to pass for free
and record this as an assumption that may be invalidated later.

\section{Our System}

% describe differences with our system
While providing support for Grace's type system is entirely possible,
previous work has given evidence that significant performance costs are involved in doing so.
We instead provide support for a very ``responds-to'' type checking system. 
For our system,
we treat a type as nothing more than a collection of method names
(illustrated by \cref{code:example-type-object}).
We evaluate whether an object conforms to a type
by checking that it can respond to each of the named methods.
Since Moth has access to the class of any object this check 
can be supported by a simple enumeration
(see the pseudo-code in \cref{code:enumeration-for-type-check}).

% advatanges to our system
The advantages of our system is that it is light-weight and fast. 
Our type system can be implemented with relatively few changes to the VM and,
since it avoids the potential for recursive loops during type checking,
much of the overhead of our implementation can be folded into compilation (see \cref{ssec:evaluation}).
While not as expressive as Grace's type system, our implementation enables
the programmer to verify whether values respond to the interfaces that they expect. 
In particular,
our simple checks can be used on the arguments passed into a method,
on the value return from a method, and also
on any assignment to or read form a variable.

\subsection{Implementation}

% obtaining type objects
To obtain the type objects,
we extract the list of method names from each literal defined by the program.
Since any two objects with the same interface are considered to be of the same type,
we create one type object for each unique interface. 
This means we can assign the same instance of type check to multiple type literals
and run time objects;
ultimately reduce the number of type checks that need to be performed.
Once we have obtained the typing information from the source program,
we attach type check nodes to the program AST.

% caching type checks
We also cache each type check during the execution of the program.
We use matrix a three-value truth matrix for the record, 
which lists each type object along its row and column (see \cref{fig:sub-typing-matrix}).
We initialize the matrix with true along its trace (each type is a subtype of itself) and 
with the leave the other cells uninitialised.
Whenever a dynamic type check runs we first obtain the type of the object from the VM, 
its expected type from the AST,
and then index the record using these types.
If the corresponding cell is uninitialized
we run the type check and store the result to the table.
Whenever a check fails we immediately throw a typing error, or otherwise
continue with the program execution 
When the corresponding cell already has been assigned a value,
we simply skip the type check and through a type error (when the cell is false)
or continue with execution (when the cell is true).
Using the cache, we can delay each check until it is needed and 
also evaluate the check between each pair of types only once.


\subsection{Optimization}

Truffle, introduced in \cref{ssec:moth}, provides a simple mechanism for us to optimize type checks.
In particular,
we can specialize how our type checks are performed by creating compiling the type-checking code
differently depending on what value is seen at run time.
