%!TEX root = ../latex/paper.tex

\section{A Dynamic Type-Checking System}
\label{sec:method}

% evaluation cases

% high flexibility, no need for global constitency 


% design goals behind Grace / Moth
As we described previously in \cref{ssec:grace}
Grace is an educational language and its performance profile
is important for supporting effective teaching. 

% motivation = give students low-overhead method to check program
In this section,
we present a new type system. 
Following from the design goals behind Grace,
our motivation with the new type system
is to provide developers
-- and particularly students --
with a low overhead and flexible system 
to check the consistency of the execution of their programs
against type annotations.

% gradual typing drawback = slow
Existing gradual typing systems 
that address the goal of flexibility currently
do yet not have the desired performance properties \cite{Takikawa2016}.

% summary of goals
instead, the design behind our type system is focused
on maximizing performance and flexibility while
preserving the ability for programmers to check the execution
of their programs.

% how we address flexible
To address the goal of flexibility we propose a system that is optional,
which enables the programmer to benefit from adding checks 
to be performed at run time,
without the burden of needing to fully type each program.

% how we address min overhead (avoid blame)
Then, to address the goal of minimal overhead, 
we propose a ``shallow'' semantics for the checks
that enables the executed behaviour of the program to be checked against
the documented types without the need to implement a full blame system 
(which leads to significant overhead in previous work).


\subsection{Design and Implementation}

% Message sending
As we described earlier in \cref{ssec:grace}, Grace is message-sending based language.
The notion of message sending suggests that one object can request that another reacts to a message,
in which case the receiver of that message can decide how to respond.

For our system we propose that a type expresses the capabilities of an object;
that is, the set of messages to which an object can respond.

As a first example imagine a student that wishes to 
design a method for getting the registration for different vehicles. 
Currently, the student only has one example to work with (see \cref{ex:object}).
The student wishes to develop the method,
without needing to think carefully about abstraction,
while having some security that their program
performs they expected.

\begin{lstlisting}[label={ex:object},caption={An object literal with a field named ``reg'' and assigns it to the ``car'' variable.}]
def car = object {
    var reg
}
\end{lstlisting}

With our system, the student can develop implement the method and 
obtain security by adding an annotation to its parameter. 
In \cref{ex:method}, the annotation
-- the keyword ``interface'' followed by a list of signatures enclosed with curly-braces --
states the argument must respond to at least the ``reg'' message. 
When executing this method at run time
our system will process the annotation,
before the method is executed,
and verify that the value provided for the ``vehicle'' argument 
can respond to the ``reg'' message.

\begin{lstlisting}[label={ex:method},caption={A method with its argument annotated with an interface literal, stating that the value must respond to at least the ``reg'' message.}]
method getRegistration(vehicle: interface { reg }) {
    return vehicle.reg
}
\end{lstlisting}



\subsection{Implementation} 
\label{sec:implementation} 


We have implemented our type system as an extension to Moth.
As we described in \cref{ssec:moth},
Moth is an AST-based.
Our system first processes all type literals declared in a program and records these as
unique entries into a global record.
When recorded, if a type of the same structure already exists we return the existing instance
rather than creating a new one.
When creating the AST for a program, 
we process any type annotations present on method and variable declarations and
recall the corresponding types from the global record. 
Any annotations using the literal syntax constituent adding a new type to the record.
Later, during runtime, we can extract the type of an object from it's factory 
(a mechanism provided by Moth to instantiate objects).
The factory maintains the definitions of the object found during parsing and
we enumerate through this record to obtain a list of names that correspond
to which methods the object can respond too.
We then consult the global record to retrieve an instance of a type object,
which can either create a new object or provide an instance already created.
Finally, we iterate through the list of members defined by the expected type 
(recalled from the AST) and verify that the objects can respond to each one.
We through an error as soon as an object fails to conform to its expected type, 
and otherwise execution continues unaffected. 

An example of the implementation is provided by \cref{code:typecheck}.

\input{../content/example-typecheck}




% \1 matrix caching type relationships
%     \2 reducing number of checks
%     \2 example of matrix 

%  \1 specializations depending on values seen at run time
%     \2 null, literals, ...
%     \2 example of type check node w specializations

% \2 compilation at method level
% \2 after inlining, constant prorogation and folding, compilation unit has fewer instructions.

\subsection{Optimization}
\label{sec:optimization}

From a high level perspective, 
our system is homogeneous with the tag-based system introduced by \citet{Greenman2017}.
The similarity is in this sense that the type of an object is expressed as a reference
to an object in the global record, which
effectively tags each run time object.

We provide two important levels of optimizations for our implementation: 
first, we maintain a three-value matrix that records all known subtyping relationships. 
Whenever we perform a type check we first examine the matrix to see if the relationship, 
between the type of an object and the expected type, has been computed before.
If already known, the previous result is returned 
or otherwise the relationship is evaluated and the matrix is updated.
This optimization alone significantly reduces the overhead of our system 
by eagerly computed each relationship only once whenever it is first required. 
\rrtodo{How can I better word next sentence?}
Since objects can share an instance of type,
an check evaluated in one location can eliminate the cost in other locations.

\smtodo{Check the following paragraph}
Finally, recall from \cref{ssec:moth} that
Moth's code is compiled using the Graal, 
which performs
constant sub-expression elimination,
method and block inlining,
aggressively propagate and fold constants, and
perform dead code elimination.
Once compiled, much of the computations for type checking
is be folded into method dispatch
(for parameter and return value checks)
and variable reads and assignments.
As we demonstrate later in \cref{sec:evaluation}, 
the overhead of our system is negligible during peak performance.
