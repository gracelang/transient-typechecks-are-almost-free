\begin{outline}

\1 Overview
    \2 Three parts required:
        \3 typing information added to AST
        \3 algorithm to evaluate if obj conforms to type
        \3 data structure for caching known subtyping relations

\1 Parsing
    \2 extract type information from ``type literal'' and propagate into AST 
    \2 expected types 
        \3 list of types (corresponding to parameter and return types) stored into field on invokable node (includes methods and blocks). 
        \3 single type stored as field on variables (includes slots and locals)

\1 Algorithm
    \2 Check types when:
        \3 dispatch starts (parameters)
        \3 dispatch ends (return value)
        \3 on variable read and write 
    \2 consult table to check if given object conforms to expected type
        \3 if sub-typing known, return previous result
        \3 if not known, evaluate sub-typing by checking obj can ``responds-to'' each signature of type
    \2 throw catchable ``type error'' on failure 

\1 Implementation Notes
    \2 Truffle specialization based on object or literal (platform block, array, number, string, boolean, and null)
    \2 Types are ``unique'' (multiple types of different names might share an instance), reduces size and number of evaluations for sub-typing table

\end{outline}